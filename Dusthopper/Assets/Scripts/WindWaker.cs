using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class WindWaker : MonoBehaviour {

    public bool generateWind = true;
    public GameObject windContainer;
    public GameObject windMaker;
    public int numPoints;
    public float windMakerRadius;

    public float delayBeforeGeneration;
    public float minExistenceTime;
    public float maxExistenceTime;

	// Use this for initialization
	void Start () {
        StartCoroutine(BalladOfGales());
	}
	
	// Update is called once per frame
	void Update () {
		
	}

    IEnumerator BalladOfGales()
    {
        while (generateWind)
        {
            yield return StartCoroutine(generate());
            foreach (Transform child in windContainer.transform)
                Destroy(child.gameObject);
            float timeBetweenGeneration = Random.Range(0, delayBeforeGeneration);
            yield return new WaitForSeconds(timeBetweenGeneration);
        }
    }
    

    public IEnumerator generate()
    {
        // Generate the endpoints for the wind current
        Vector2 endpoint1 = Random.insideUnitCircle.normalized * 100;
        Vector2 endpoint2 = -endpoint1;

        Vector2 centerOffset = new Vector2(Random.Range(-100, 100), Random.Range(-100, 100));
        endpoint1 += centerOffset;
        endpoint2 += centerOffset;

        // Calculate points 1/3 and 2/3 along the line generated by the endpoints
        Vector2 midpoint1 = .33f * endpoint1 + .66f * endpoint2;
        Vector2 midpoint2 = .66f * endpoint1 + .33f * endpoint2;

        // Calculate a vector perpendicular to the line and random offsets to generate bezier curve
        Vector2 unitPerp = Quaternion.AngleAxis(90, Vector3.forward) * (endpoint2 - endpoint1).normalized;
        float offset1 = Random.Range(-100, 100);
        float offset2 = Random.Range(-100, 100);
        // Generate the newly offset points
        midpoint1 += (unitPerp * offset1);
        midpoint2 += (unitPerp * offset2);

        float timeInterval = 1.0f / numPoints;
        Vector2 point;
        Vector2 direction;
        for (int x = 0; x <= numPoints; x++)
        {
            float currInterval = x * timeInterval;
            point = (1 - currInterval) * (1 - currInterval) * (1 - currInterval) * endpoint1 +
                        3 * (1 - currInterval) * (1 - currInterval) * currInterval * midpoint1 +
                        3 * (1 - currInterval) * currInterval * currInterval * midpoint2 +
                        currInterval * currInterval * currInterval * endpoint2;
            direction = (3 * (1 - currInterval) * (1 - currInterval) * (midpoint1 - endpoint1) +
                        6 * (1 - currInterval) * currInterval * (midpoint2 - midpoint1) +
                        3 * currInterval * currInterval * (endpoint2 - midpoint2)).normalized;

            GameObject inst = Instantiate(windMaker, point, Quaternion.identity, windContainer.transform);
            inst.GetComponent<WindMaker>().windDirection = direction;
            inst.GetComponent<CircleCollider2D>().radius = windMakerRadius;
        }

        float existenceTime = Random.Range(minExistenceTime, maxExistenceTime);
        yield return new WaitForSeconds(existenceTime);
    }


}
